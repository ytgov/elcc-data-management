#!/usr/bin/env ruby

require "shellwords"
require "rdoc"

require_relative "./jira_api"
require_relative "./pull_request_editor"

class DevHelper
  # Support dashes in command names
  COMMAND_TO_METHOD = {
    "ts-node" => :ts_node,
    "branch-from" => :branch_from,
    "description-from" => :description_from,
    "check-types" => :check_types,
    "edit-pr" => :edit_pr,
    "sqlcmd-query" => :sqlcmd_query,
  }
  METHOD_TO_COMMAND = COMMAND_TO_METHOD.invert

  REPLACE_PROCESS = "replace_process"
  WAIT_FOR_PROCESS = "wait_for_process"

  # External Interface
  def self.call(*args)
    new.call(*args)
  end

  # Core logic
  def call(*args, **kwargs)
    command = args[0]
    method = COMMAND_TO_METHOD.fetch(command, command)
    if args.length.positive? && respond_to?(method)
      public_send(method, *args.drop(1), **kwargs)
    else
      compose(*args, **kwargs)
    end
  end

  def compose(*args, **kwargs)
    command = compose_command(*args, **kwargs)
    puts "Running: #{command}"

    case kwargs[:execution_mode]
    when WAIT_FOR_PROCESS
      system(command)
    else
      exec(command)
    end
  end

  # Primary command wrappers
  def build(*args, **kwargs)
    compose(%w[build], *args, **kwargs)
  end

  def up(*args, **kwargs)
    compose(*%w[up --remove-orphans], *args, **kwargs)
  end

  def down(*args, **kwargs)
    compose(*%w[down --remove-orphans], *args, **kwargs)
  end

  def logs(*args, **kwargs)
    compose(*%w[logs -f], *args, **kwargs)
  end

  def run(*args, **kwargs)
    compose(*%w[run --rm], *args, **kwargs)
  end

  # Custom helpers

  def check_types(*args, **kwargs)
    run(*%w[api npm run check-types], *args, **kwargs)
  end

  def sh(*args, **kwargs)
    run(*%w[api sh], *args, **kwargs)
  end

  def debug
    api_container_id = container_id("api")
    puts "Waiting for breakpoint to trigger..."
    puts "'ctrl-c' to exit."
    command = "docker attach --detach-keys ctrl-c #{api_container_id}"
    puts "Running: #{command}"
    exec(command)
    exit 0
  end

  def web(*args, **kwargs)
    run(*%w[web], *args, **kwargs)
  end

  def api(*args, **kwargs)
    run(*%w[api], *args, **kwargs)
  end

  def npm(*args, **kwargs)
    run(*%w[api npm], *args, **kwargs)
  end

  def ts_node(*args, **kwargs)
    run(*%w[api npm run ts-node], *args, **kwargs)
  end

  def test(*args, **kwargs)
    service = args[0]
    if service == "api"
      test_api(*args.drop(1), **kwargs)
    elsif service == "web"
      test_web(*args.drop(1), **kwargs)
    else
      test_api(*args, **kwargs)
    end
  end

  def test_api(*args, **kwargs)
    reformat_project_relative_path_filter_for_vitest!(args, "api/")
    run(*%w[test_api npm run test], *args, **kwargs)
  end

  def test_web(*args, **kwargs)
    reformat_project_relative_path_filter_for_vitest!(args, "web/")
    run(*%w[test_web npm run test], *args, **kwargs)
  end

  def migrate(*args, **kwargs)
    action = args[0]
    if action == "up"
      migrate_api(*%w[up -- --step=1], *args.drop(1), **kwargs)
    elsif action == "down"
      migrate_api(*%w[down -- --step=1], *args.drop(1), **kwargs)
    else
      migrate_api(*args, **kwargs)
    end
  end

  def migrate_api(*args, **kwargs)
    run(*%w[api npm run migrate], *args, **kwargs)
  end

  def seed(*args, **kwargs)
    run(*%w[api npm run seed], *args, **kwargs)
  end

  # -I enable quoted identifiers, e.g. "table"."column"
  def sqlcmd(*args, **kwargs)
    environment_variable_export_commands =
      ENV
        .slice(*%w[DB_NAME DB_USER DB_HOST DB_PORT])
        .map { |key, value| "export #{key}=\"#{value}\"" }
        .join("\n  ")

    tty_argument = ""
    tty_argument = "-T" if kwargs.fetch(:enable_tty, false)

    compose(<<~BASH, **kwargs)
      exec #{tty_argument} db sh -c '
        #{environment_variable_export_commands}
        /opt/mssql-tools18/bin/sqlcmd \
          -U "$DB_USER" \
          -P "$DB_PASS" \
          -H "$DB_HOST" \
          -d "$DB_NAME" \
          -C \
          -I #{args.join(" ")}
        '
    BASH
  end

  def sqlcmd_query(query, *args, **kwargs)
    if query.nil? || query.strip.empty?
      raise ArgumentError, "Query cannot be nil or empty"
    end

    sqlcmd(args, enable_tty: true, pipe_input: query, **kwargs)
  end

  def db(*args, **kwargs)
    compose(*%w[exec db], *args, **kwargs)
  end

  def ownit(*args, **kwargs)
    file_or_directory = args[0]
    raise ScriptError, "Must provide a file or directory path." if file_or_directory.nil?

    if RUBY_PLATFORM =~ /linux/
      puts "Take ownership of the file or directory? #{file_or_directory}"
      exec("sudo chown -R #{user_id}:#{group_id} #{file_or_directory}")
    else
      raise NotImplementedError, "Not implement for platform #{RUBY_PLATFORM}"
    end
  end

  ##
  # Generates and checks out a new branch based on the Jira issue URL.
  # Example:
  #   dev branch-from https://yg-hpw.atlassian.net/browse/ELCC-61
  #
  # Produces:
  #   git checkout -b elcc-61/add-wage-enhancement-replication-across-months
  def branch_from(jira_issue_url, *args, **kwargs)
    branch_name = JiraApi.build_branch_name(jira_issue_url)
    system("git checkout -b #{branch_name}")
  end

  ##
  # Fetches the description of a Jira issue and prints it to the console in markdown format.
  # Example:
  #   dev description-from https://yg-hpw.atlassian.net/browse/ELCC-61
  #
  # Produces:
  #   ... a bunch of markdown text ...
  def description_from(jira_issue_url, *args, **kwargs)
    description = JiraApi.fetch_description_as_markdown(jira_issue_url)
    puts description
  end

  ##
  # Edits the description of a pull request.
  # Example:
  #   dev edit-pr https://github.com/icefoganalytics/travel-authorization/pull/218
  def edit_pr(pull_request_url, *args, **kwargs)
    PullRequestEditor.edit_pull_request_description(pull_request_url, *args, **kwargs)
    exit(0)
  end

  def bash_completions
    completions =
      public_methods(false)
        .reject { |word| %i[call].include?(word) }
        .map { |word| METHOD_TO_COMMAND.fetch(word, word) }
    puts completions
  end

  ##
  # Generate help documentation.
  def help(*args, **kwargs)
    rdoc = RDoc::RDoc.new
    rdoc_arguements = %w[--dry-run --quiet] + [__FILE__]
    rdoc.document(rdoc_arguements)
    rdoc_data_for_class = rdoc.store.classes_hash["DevHelper"]

    puts <<~HELP.chomp
      Development Helper.

      Usage:
        dev <command> [args]

      Available commands:
    HELP

    all_public_methods = public_methods(false).sort
    all_public_methods.delete(:call)
    longest_command_length = all_public_methods.map(&:length).max

    all_public_methods.each do |method_name|
      method_doc = rdoc_data_for_class.find_method_named(method_name.to_s)
      command = METHOD_TO_COMMAND.fetch(method_name, method_name)
      comment = method_doc.comment

      print "  #{command}"
      unless comment.empty?
        first_line_of_comment = comment.to_s.lines[0].strip
        pad = "-" * (longest_command_length - command.length + 1)
        print " #{pad} #{first_line_of_comment}"
      end
      print "\n"
    end

    command = compose_command("<args>")
    puts "\nFallback for unknown commands is to run `#{command}`."
  end

  private

  def container_id(container_name, *args, **kwargs)
    command = compose_command(*%w[ps -q], container_name, *args, **kwargs)
    puts "Running: #{command}"
    id_of_container = `#{command}`.chomp
    puts "Container id is: #{id_of_container}"
    id_of_container
  end

  def compose_command(*args, **kwargs)
    environment = kwargs.delete(:environment) { "development" }
    pipe_input = kwargs.delete(:pipe_input)

    go_to_project_root = "cd #{project_root}"
    bootstrap_docker = "docker compose -f docker-compose.#{environment}.yaml #{args.join(' ')}"

    if pipe_input
      shell_safe_pipe_input = Shellwords.escape(pipe_input)
      pipe_input_to_compose = "printf '%s\\n' #{shell_safe_pipe_input} |"

      <<~BASH
        #{go_to_project_root} && \
        #{pipe_input_to_compose} #{dynamic_environment_variables} #{bootstrap_docker}
      BASH
    else
      <<~BASH
        #{go_to_project_root} && \
        #{dynamic_environment_variables} #{bootstrap_docker}
      BASH
    end
  end

  def project_root
    @project_root ||= File.absolute_path("#{__dir__}/..")
  end

  def dynamic_environment_variables
    if RUBY_PLATFORM =~ /linux/
      %(HOST_USER_ID="#{user_id}" HOST_GROUP_ID="#{group_id}")
    else
      ""
    end
  end

  def user_id
    unless RUBY_PLATFORM =~ /linux/
      raise NotImplementedError, "Not implement for platform #{RUBY_PLATFORM}"
    end

    `id -u`.strip
  end

  def group_id
    unless RUBY_PLATFORM =~ /linux/
      raise NotImplementedError, "Not implement for platform #{RUBY_PLATFORM}"
    end

    `id -g`.strip
  end

  def reformat_project_relative_path_filter_for_vitest!(args, prefix)
    if args.length.positive? && args[0].start_with?(prefix)
      src_path_prefix = "#{prefix}src/"
      test_path_regex = Regexp.escape(prefix)
      src_path_regex = Regexp.escape(src_path_prefix)

      if args[0].start_with?(src_path_prefix)
        args[0] = args[0].gsub(/^#{src_path_regex}/, "tests/").gsub(/\.ts$/, ".test.ts")
        # TODO: handle other file types
      else
        args[0] = args[0].gsub(/^#{test_path_regex}/, "")
      end

      puts "Reformatted path filter from project relative to service relative for vitest."
    end
  end
end

# Only execute main function when file is executed
DevHelper.call(*ARGV) if $PROGRAM_NAME == __FILE__

## Dev completions
# https://iridakos.com/programming/2018/03/01/bash-programmable-completion-tutorial
# _dev_completions () {
#   local dev_command_path="$(which dev)"
#   local dev_function_names
#   dev_function_names="$(ruby "$dev_command_path" bash_completions)"
#   # COMP_WORDS: an array of all the words typed after the name of the program the compspec belongs to
#   # COMP_CWORD: an index of the COMP_WORDS array pointing to the word the current cursor is at - in other words, the index of the word the cursor was when the tab key was pressed
#   # COMP_LINE: the current command line
#   COMPREPLY=($(compgen -W "$dev_function_names" "${COMP_WORDS[$COMP_CWORD]}"))
# }

# complete -F _dev_completions dev
# complete -W "allow" direnv
